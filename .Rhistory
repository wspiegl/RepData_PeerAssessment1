install.packages("xslx")
install.packages("xlsx")
install.packages("rJava")
quit()
install.packages("rJava")
install.packages("xlsx")
exit
quit()
sqrt(.5)
.5*.5
x <- 1:4
p <- x/sum(x)
temp <- rbind(x, p)
rownames(temp) <- c("X", "Prob")
temp
(1.0*0.1 + 2.0*.2 + 3.0*0.3 + 4.0 * 0.4)/4
(1.0*0.1 + 2.0*.2 + 3.0*0.3 + 4.0 * 0.4)
n <- 5
pvals <- seq(0, 1, length = 1000)
plot(c(0, 1), c(0, 1.2), type = "n", frame = FALSE, xlab = "p", ylab = "likelihood")
text((0 : n) /n, 1.1, as.character(0 : n))
sapply(0 : n, function(x) {
phat <- x / n
if (x == 0) lines(pvals, ( (1 - pvals) / (1 - phat) )^(n-x), lwd = 3)
else if (x == n) lines(pvals, (pvals / phat) ^ x, lwd = 3)
else lines(pvals, (pvals / phat ) ^ x * ( (1 - pvals) / (1 - phat) ) ^ (n-x), lwd = 3)
}
)
title(paste("Likelihoods for n = ", n))
pvals <- seq(0, 1, length = 1000)
pvals
svm
1000/1787
(1000/1787)*100
10/1787
ppois(10-)
100/1787
ppois(10-(100/1787),1,lower.tail=F)
ppois(10-(1000/1787),1,lower.tail=F)
ppois(10-(10/1787),1,lower.tail=F)
ppois(9.9,1,lower.tail=f)
ppois(9.9,1,lower.tail=F)
ppois(99,1,lower.tail=F)
ppois(9.9,1,lower.tail=F)
ppois(9.9,10,lower.tail=F)
1-ppois(9,1787,lower.tail=F)
ppois(9,1787,lower.tail=F)
ppois(9,17.87,lower.tail=F)
1-ppois(9,17.87,lower.tail=F)
mn<-12
s<-4
z<- qnorm(.05)
mu0 <- mn - z * s
mu0
mn - z * s / sqrt(100)
12.7
ppois(9,17.87,lower.tail=TRUE)
ppois(9,17.87,lower.tail=F)
1-ppois(9,17.87,lower.tail=T)
1-ppois(9,17.87,lower.tail=F)
> ppois(10,17.87,lower.tail=T)
ppois(10,17.87,lower.tail=T)
power.t.test(n = 100, delta=.1 , sd=.04 , type = “one.sample”, alt= “one.sided”)$power
power.t.test(n=100, delta=.01, sd=0.04, type = "one.sample", alt="one.sided")$power
power.t.test(n=100, delta=.01, sd=0.04, type = "one.sample", alt="one.sided")$n
power.t.test(n=100, delta=0.1, sd=0.04, type = "one.sample", alt="one.sided")$power
power.t.test(n=100, delta=.01, sd=0.04, type = "one.sample", alt="one.sided")$n
power.t.test(n=100, delta=.01, sd=0.04, type = "one.sample", alt="one.sided")$power
power.t.test(power=.90, delta=.01, sd=.04, type="one.sample", alt="one.sided")$n
mn<-12
s<-4
z<- qnorm(.95)
mn - z * (s / sqrt(100)
)
mn<-12
s<-4
z<- qnorm(.95)
mn - z * s / sqrt(100)
pbinom(2,4,prob=0.5,lower.tail=FALSE)
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="less",paired=TRUE)
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="two.sided",paired=TRUE)
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="two.sided",paired=F)
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="two.sided",paired=TRUE)
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="two.sided",paired=TRUE)
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="two.sided",paired=TRUE)$p-value
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="two.sided",paired=TRUE)
t.test(c(132,135,151,146,130)-c(140,138,150,148,135),alternative="two.sided")
p-value = 0.086522.) t.test(c(132,135,151,146,130)-c(140,138,150,148,135),alternative="two.sided")
t.test(c(132,135,151,146,130)-c(140,138,150,148,135),alternative="two.sided")
t.test(c(132,135,151,146,130),c(140,138,150,148,135),alternative="two.sided",paired=TRUE)
getwd()
setwd("~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1")
some <- by()
steps4impute <- read.csv("./data/activity.csv")
for (i in indices.of.rows.with.missing.values) {
steps4impute[i, "steps"] <-
dayPatterns[as.character(steps4impute[i, "interval"])]
}
steps4impute <- read.csv("./data/activity.csv")
for (i in indices.of.rows.with.missing.values) {
steps4impute[i, "steps"] <-
dayPatterns[as.character(steps4impute[i, "interval"])]
}
indices.of.rows.with.missing.values <- which( ! complete.cases( steps ) )
number.of.missing.value.rows <- length( indices.of.rows.with.missing.values )
indices.of.rows.with.missing.values <- which( ! complete.cases( steps ) )
number.of.missing.value.rows <- length( indices.of.rows.with.missing.values )
indices.of.rows.with.missing.values <- which( ! complete.cases( steps ) )
number.of.missing.value.rows <- length( indices.of.rows.with.missing.values )
steps <- read.csv("./data/activity.csv")
stepsClean <- steps[complete.cases(steps),]
steps <- read.csv("./data/activity.csv")
stepsClean <- steps[complete.cases(steps),]
indices.of.rows.with.missing.values <- which( ! complete.cases( steps ) )
number.of.missing.value.rows <- length( indices.of.rows.with.missing.values )
steps4impute <- read.csv("./data/activity.csv")
for (i in indices.of.rows.with.missing.values) {
steps4impute[i, "steps"] <-
dayPatterns[as.character(steps4impute[i, "interval"])]
}
dayPatterns <-
tapply(stepsClean$steps, stepsClean$interval, FUN=mean, rm.a = T)
steps4impute <- read.csv("./data/activity.csv")
for (i in indices.of.rows.with.missing.values) {
steps4impute[i, "steps"] <-
dayPatterns[as.character(steps4impute[i, "interval"])]
}
for ( i in 1:nrow(steps4impute)) {
steps4impute$wday[i] <-
ifelse(as.POSIXlt(steps4impute$date[i])$wday %in% 1:5, "weekday", "weekend")
}
some <- by(steps4impute, list(steps4impute$wday, steps4impute$interval), mean, rm.na=T)
some
hist(some)
str(some)
class(some)
some
head(some)
head(steps4impute)
str(steps4impute)
some <- by(steps4impute, steps4impute$interval, mean, rm.na=T)
some <- by(steps4impute, steps4impute$interval, mean)
warnings()
some <- by(steps4impute$steps, steps4impute$interval, mean)
head(some)
some <- by(steps4impute$steps, list(steps4impute$wday,steps4impute$interval), mean)
head(some)
some
str(some)
some.df <- as.data.frame(some)
tail(some)
some
some <- by(steps4impute$steps, list(steps4impute$wday,steps4impute$interval), mean, simplify=T)
some
some <- by(steps4impute$steps, list(steps4impute$wday,steps4impute$interval), mean, simplify=F)
some
tail(some)
some
head(steps4impute)
s1 <- melt(steps4impute[,c(1,3,4)], id.vars=c(interval, wday))
library(reshape2)
s1 <- melt(steps4impute[,c(1,3,4)], id.vars=c(interval, wday))
s1 <- melt(steps4impute[,c(1,3,4)], id.vars=c("interval", "wday"))
head(s1)
s2 <- dcast(s1, interval + wday ~ varaible, mean)
s2 <- dcast(s1, interval + wday ~ variable, mean)
head(s2)
head(s1)
head(steps4impute)
s2 <- dcast(s1, interval + wday ~ steps, mean)
s2 <- dcast(steps4impute, interval + wday ~ steps, mean)
s2
s2 <- dcast(s1, interval + wday ~ variable, mean)
s2
s2 <- dcast(s1, wday + interval ~ variable, mean)
s2
s2 <- dcast(s1, interval + wday ~ variable, mean)
s2
head(s2)
library(lattice)
xyplot(s2$interval ~ s2$steps | s2$wday, layout = c(1, 2))  ## Plot with 2 panels
xyplot(s2$steps ~ s2$interval | s2$wday, layout = c(1, 2))  ## Plot with 2 panels
xyplot(s2$steps ~ s2$interval | s2$wday, layout = c(1, 2), type="l")  ## Plot with 2 panels
xyplot(s2$steps ~ s2$interval | s2$wday, layout = c(1, 2), type="l", xlab = "Interval", ylab="Number of steps")  ## Plot with 2 panels
levels(s2)<-c("weekday","weekend")
xyplot(s2$steps ~ s2$interval | s2$wday, layout = c(1, 2), type="l", xlab = "Interval", ylab="Number of steps")  ## Plot with 2 panels
levels(s2)<-c(weekend", "weekday")
levels(s2)<-c("weekend", "weekday")
levels(s2)<-c("weekday","weekend")
levels(s2)<-c("weekend", "weekday")
setwd("~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1")
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
library("knitr", lib.loc="/home/wspiegl/R/x86_64-pc-linux-gnu-library/3.0")
s1
s2
xyplot(s2$steps ~ s2$interval | s2$wday, layout = c(1, 2),
type="l", xlab = "Interval", ylab="Number of steps")
source('~/courses/coursera/Reproducible Research/wd/RepData_PeerAssessment1/someR.R')
hist(stepsPerDay)
dayPatterns <-
tapply(stepsClean$steps, stepsClean$interval, FUN=mean, rm.a = T)
# simple, with default tick marks
# plot(levels(as.factor(stepsClean$interval)), dayPatterns, type="l",
#    ylab="Step count [per 5-min interval]", xlab="5-minute time interval during the day",
#    main = "Average daily activity pattern")
# more costly with custom labels on tick marks
plot(dayPatterns, type="l", xaxt="n", xlab="Time")
dayPatterns <-
tapply(stepsClean$steps, stepsClean$interval, FUN=mean, rm.a = T)
# simple, with default tick marks
# plot(levels(as.factor(stepsClean$interval)), dayPatterns, type="l",
#    ylab="Step count [per 5-min interval]", xlab="5-minute time interval during the day",
#    main = "Average daily activity pattern")
# more costly with custom labels on tick marks
plot(dayPatterns, type="l", xaxt="n", xlab="Time")
axis(1,
at <- seq(1, to=288, length.out=10),
labels <- names(dayPatterns)[seq(1, to=288, length.out=10)],
las=2)
# gimme the index-position (with index-name aka 5-min-interval) of the max-value
which.max(dayPatterns)
## Imputing missing values
# 1. total number of missing values in the dataset
indices.of.rows.with.missing.values <- which( ! complete.cases( steps ) )
number.of.missing.value.rows <- length( indices.of.rows.with.missing.values )
# 2. devise a strategy for filling in all of the missing values in the dataset
# example: mean/median for that day or mean for that 5-minute interval
# solution: take mean from the dayPatterns-data.frame (s.o)
# 3. Create a new dataset that is equal to the original dataset
# but with the missing data filled in.
# for each row, do
# a) get the row with the missing value: rowIndex.with.missing.value
# b) imput by stepsImpute[rowIndex.with.missing.value, stepsImpute$steps]
#                 <- dayPatterns[stepsImpute[rowIndex.with.missing.value,
#                                            stepsImpute$interval], dayPatterns$steps]
steps4impute <- read.csv("./data/activity.csv")
for (i in indices.of.rows.with.missing.values) {
steps4impute[i, "steps"] <-
dayPatterns[as.character(steps4impute[i, "interval"])]
}
# 4. Make a histogram of the total number of steps taken each day
# and Calculate and report the mean and median total number of steps
# taken per day. Do these values differ from the estimates from
# the first part of the assignment? What is the impact of imputing
# missing data on the estimates of the total daily number of steps?
# Sum up all 5-min values per day (tapply) and get the mean/median over all days
stepsPerDayFilled <- tapply(steps4impute$steps,
as.factor(as.character(steps4impute$date)),
FUN=sum, rm.na=T)
mn <- mean(stepsPerDayFilled,na.rm = T)
md <- median(stepsPerDayFilled,na.rm = T)
hist(stepsPerDayFilled)
nrow(stepsPerDay)
nrow(stepsPerDayFilled)
## Are there differences in activity patterns between weekdays and weekends?
# 1. Create a new factor variable in the dataset with two levels – “weekday”
# and “weekend” indicating whether a given date is a weekday or weekend day.
print(nrow(steps4impute))
# calc for weekday or not
# as.POSIXlt("2012-10-06")$wday %in% c(0,6)
for ( i in 1:nrow(steps4impute)) {
steps4impute$wday[i] <-
ifelse(as.POSIXlt(steps4impute$date[i])$wday %in% 1:5, "weekday", "weekend")
}
# 2. Make a panel plot containing a time series plot (i.e. type = "l") of
# the 5-minute interval (x-axis) and the average number of steps taken,
# averaged across all weekday days or weekend days (y-axis).
#lattice-package
library(lattice)
# > set.seed(10)
# > x <- rnorm(100)
# > f <- rep(0:1, each = 50)
# > y <- x + f - f * x + rnorm(100, sd = 0.5)
# > f <- factor(f, labels = c("Group 1", "Group 2"))
# > xyplot(y ~ x | f, layout = c(1, 2))  ## Plot with 2 panels
#plot(levels(as.factor(stepsClean$interval)), dayPatterns, type="l",
#    ylab="Step count [per 5-min interval]", xlab="5-minute time interval during the day",
#    main = "Average daily activity pattern")
# names(steps4impute)[names(steps4impute)=="weekday"] <- wd
#
# weekday.steps <- steps4impute["wday" == "weekend",]
# weekday.pattern <-
#   tapply(stepsClean$steps, stepsClean$interval, FUN=mean, rm.a = T)
#
# > weekend.steps <- steps4impute[steps4impute$wday == "weekend",]
# > weekday.steps <- steps4impute[steps4impute$wday == "weekday",]
# > nrow(weekday.steps)
# [1] 12960
# > nrow(weekend.steps)
# [1] 4608
# >
s1 <- melt(steps4impute[,c(1,3,4)], id.vars=c("interval", "wday"))
s2 <- dcast(s1, interval + wday ~ variable, mean)
xyplot(s2$steps ~ s2$interval | s2$wday, layout = c(1, 2),
type="l", xlab = "Interval", ylab="Number of steps")
